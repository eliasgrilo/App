# Firebase Data Connect - Padoca Application
# PostgreSQL Schema Definition

# ===========================================================
# SUPPLIERS
# ===========================================================

type Supplier @table {
  id: UUID! @default(expr: "uuidV4()")
  name: String!
  email: String
  autoRequest: Boolean! @default(value: false)  # Enable automated quotation creation on low stock
  phone: String
  address: String
  cnpj: String
  category: String
  notes: String
  isActive: Boolean! @default(value: true)
  createdAt: Timestamp! @default(expr: "request.time")
  updatedAt: Timestamp! @default(expr: "request.time")
}

# ===========================================================
# PRODUCTS (Inventory Items)
# ===========================================================

type Product @table {
  id: UUID! @default(expr: "uuidV4()")
  name: String!
  category: String
  subcategory: String
  unit: String! @default(value: "un")
  packageQuantity: Float @default(value: 1)
  packageCount: Int @default(value: 1)
  pricePerUnit: Float @default(value: 0)
  totalCost: Float @default(value: 0)
  minStock: Float @default(value: 0)
  maxStock: Float @default(value: 0)
  location: String
  barcode: String
  supplier: Supplier @relation
  notes: String
  imageUrl: String
  isActive: Boolean! @default(value: true)
  createdAt: Timestamp! @default(expr: "request.time")
  updatedAt: Timestamp! @default(expr: "request.time")
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # AI Enhancement Fields (Apple-Google Integration)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  confidenceScore: Float @default(value: 0)       # AI prediction confidence (0-1)
  semanticMapping: String                          # JSON: {"canonical": "Coca-Cola 350ml", "aliases": ["Refri Lata"]}
  aiMetadata: String                               # JSON: {"lastAnalyzed": "...", "source": "invoice", "model": "gemini-1.5-pro"}
  priceHistory: String                             # JSON array: [{"date": "...", "price": ..., "source": "..."}]
  spatialAnchor: String                            # @DEPRECATED: AR feature not yet implemented
}

# ===========================================================
# PRODUCT MOVEMENTS (Audit Trail)
# ===========================================================

enum MovementType {
  ENTRY
  EXIT
}

type ProductMovement @table {
  id: UUID! @default(expr: "uuidV4()")
  product: Product! @relation
  type: MovementType!
  quantity: Float!
  price: Float
  reason: String
  location: String
  userId: String
  userName: String
  notes: String
  createdAt: Timestamp! @default(expr: "request.time")
}

# ===========================================================
# PRODUCT NOTES
# ===========================================================

enum NoteCategory {
  GENERAL
  QUALITY
  DELIVERY
  PRICE
}

type ProductNote @table {
  id: UUID! @default(expr: "uuidV4()")
  product: Product! @relation
  category: NoteCategory! @default(value: GENERAL)
  content: String!
  userId: String
  userName: String
  createdAt: Timestamp! @default(expr: "request.time")
}

# ===========================================================
# COSTS (Operating Expenses)
# ===========================================================

enum CostType {
  FIXED
  VARIABLE
}

type Cost @table {
  id: UUID! @default(expr: "uuidV4()")
  name: String!
  category: String
  type: CostType! @default(value: VARIABLE)
  amount: Float!
  date: Date!
  recurrence: String
  supplier: Supplier @relation
  notes: String
  attachmentUrl: String
  createdAt: Timestamp! @default(expr: "request.time")
  updatedAt: Timestamp! @default(expr: "request.time")
}

# ===========================================================
# COST CATEGORIES
# ===========================================================

type CostCategory @table {
  id: UUID! @default(expr: "uuidV4()")
  name: String!
  color: String @default(value: "#8b5cf6")
  icon: String @default(value: "ğŸ“¦")
  order: Int @default(value: 0)
  createdAt: Timestamp! @default(expr: "request.time")
}

# ===========================================================
# INVENTORY CATEGORIES
# ===========================================================

type InventoryCategory @table {
  id: UUID! @default(expr: "uuidV4()")
  name: String!
  color: String @default(value: "#8b5cf6")
  icon: String @default(value: "ğŸ“¦")
  order: Int @default(value: 0)
  createdAt: Timestamp! @default(expr: "request.time")
}

# ===========================================================
# RECIPES
# ===========================================================

type Recipe @table {
  id: UUID! @default(expr: "uuidV4()")
  name: String!
  category: String
  description: String
  servings: Int @default(value: 1)
  prepTime: Int
  cookTime: Int
  totalTime: Int
  difficulty: String
  imageUrl: String
  videoUrl: String
  notes: String
  isPublished: Boolean! @default(value: false)
  createdAt: Timestamp! @default(expr: "request.time")
  updatedAt: Timestamp! @default(expr: "request.time")
}

# ===========================================================
# RECIPE INGREDIENTS
# ===========================================================

type RecipeIngredient @table {
  id: UUID! @default(expr: "uuidV4()")
  recipe: Recipe! @relation
  product: Product @relation
  name: String!
  quantity: Float!
  unit: String!
  notes: String
  order: Int @default(value: 0)
}

# ===========================================================
# RECIPE INSTRUCTIONS
# ===========================================================

type RecipeInstruction @table {
  id: UUID! @default(expr: "uuidV4()")
  recipe: Recipe! @relation
  stepNumber: Int!
  content: String!
  duration: Int
  tip: String
  imageUrl: String
}

# ===========================================================
# RECIPE CATEGORIES
# ===========================================================

type RecipeCategory @table {
  id: UUID! @default(expr: "uuidV4()")
  name: String!
  color: String @default(value: "#8b5cf6")
  icon: String @default(value: "ğŸ•")
  order: Int @default(value: 0)
  createdAt: Timestamp! @default(expr: "request.time")
}

# ===========================================================
# KANBAN BOARD
# ===========================================================

enum KanbanStatus {
  TODO
  IN_PROGRESS
  DONE
}

type KanbanTask @table {
  id: UUID! @default(expr: "uuidV4()")
  title: String!
  description: String
  status: KanbanStatus! @default(value: TODO)
  priority: Int @default(value: 0)
  dueDate: Date
  recipe: Recipe @relation
  assignee: String
  order: Int @default(value: 0)
  createdAt: Timestamp! @default(expr: "request.time")
  updatedAt: Timestamp! @default(expr: "request.time")
}

# ===========================================================
# FILES (Storage References)
# ===========================================================

enum FileType {
  IMAGE
  PDF
  DOCUMENT
  OTHER
}

type File @table {
  id: UUID! @default(expr: "uuidV4()")
  name: String!
  type: FileType!
  mimeType: String!
  size: Int!
  storageUrl: String!
  storagePath: String!
  thumbnailUrl: String
  entityType: String
  entityId: String
  uploadedBy: String
  createdAt: Timestamp! @default(expr: "request.time")
}

# ===========================================================
# QUOTATIONS (AI Module)
# ===========================================================

enum QuotationStatus {
  PENDING
  SENT
  WAITING
  RECEIVED
  APPROVED
  REJECTED
}

type Quotation @table {
  id: UUID! @default(expr: "uuidV4()")
  requestId: String @unique                      # Unique ID for email tracking [REQ-xxx]
  supplier: Supplier! @relation
  status: QuotationStatus! @default(value: PENDING)
  sentAt: Timestamp
  respondedAt: Timestamp
  totalValue: Float
  notes: String
  emailThreadId: String
  softDeleted: Boolean! @default(value: false)   # Soft delete for audit trail
  deletedAt: Timestamp                            # When soft-deleted
  createdAt: Timestamp! @default(expr: "request.time")
  updatedAt: Timestamp! @default(expr: "request.time")
}

type QuotationItem @table {
  id: UUID! @default(expr: "uuidV4()")
  quotation: Quotation! @relation
  product: Product! @relation
  requestedQuantity: Float!
  quotedPrice: Float
  quotedQuantity: Float
  notes: String
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# UNIQUE PROTOCOL: QuotationItem Duplicate Prevention
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# This constraint ensures a product can only appear ONCE per quotation.
# Database will REJECT any duplicate (quotation, product) combinations.

extend type QuotationItem {
  # UNIQUE CONSTRAINT: Same product cannot be added twice to same quotation
  itemByQuotationProduct: QuotationItem @unique(fields: ["quotation", "product"])
}


# ===========================================================
# AUTO-QUOTE REQUEST (AI Auto-Quote System - State Machine)
# ===========================================================
# Manages the automated quotation workflow with strict duplicate prevention
# Flow: PENDING â†’ AWAITING â†’ PROCESSING â†’ ORDERED â†’ RECEIVED

enum AutoQuoteStatus {
  PENDING     # Created by background job, waiting for user to send
  AWAITING    # Email sent, waiting for supplier reply
  PROCESSING  # Email received, AI analyzing
  ORDERED     # Order card created from AI extraction
  RECEIVED    # Goods received, inventory updated
  CANCELLED   # User cancelled
  EXPIRED     # No reply within 7 days
}

type AutoQuoteRequest @table {
  id: UUID! @default(expr: "uuidV4()")
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # UNIQUE IDENTIFIERS - Strict duplicate prevention
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  requestId: String! @unique                    # [REQ-xxx] - Unique tracking ID for email correlation
  deduplicationKey: String! @unique             # "productId:supplierId" - Prevents duplicate pending cards
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # RELATIONS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  product: Product! @relation
  supplier: Supplier! @relation
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # REQUEST DATA
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  requestedQuantity: Float!
  currentStock: Float
  minStock: Float
  unit: String @default(value: "un")
  status: AutoQuoteStatus! @default(value: PENDING)
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # EMAIL TRACKING
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  emailSentAt: Timestamp
  emailMessageId: String
  emailThreadId: String
  emailSubject: String
  emailBody: String
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # AI EXTRACTED DATA (From supplier response)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  quotedPrice: Float
  quotedAvailability: String
  quotedDeliveryDate: Date
  quotedDeliveryDays: Int
  quotedPaymentTerms: String
  aiConfidence: Float                           # 0-1 confidence score
  aiRawResponse: String                         # Full AI response JSON
  hasProblems: Boolean @default(value: false)
  problemSummary: String
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ORDER REFERENCE
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  orderId: String                               # Links to OrderCard when created
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SOFT DELETE FOR AUDIT TRAIL
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  softDeleted: Boolean! @default(value: false)
  deletedAt: Timestamp
  deletedBy: String
  deletedReason: String
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # METADATA
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  createdAt: Timestamp! @default(expr: "request.time")
  updatedAt: Timestamp! @default(expr: "request.time")
  createdBy: String
  createdByName: String
}

# ===========================================================
# ORDER CARD (Created from AI-processed quotation)
# ===========================================================
# Represents a confirmed order after AI extracts quote data
# Strictly linked 1:1 with AutoQuoteRequest via requestId

enum OrderCardStatus {
  PENDING     # Created from AI extraction, awaiting confirmation
  CONFIRMED   # User confirmed the order
  SHIPPED     # Supplier marked as shipped
  RECEIVED    # Goods received, inventory updated
  CANCELLED   # Order cancelled (soft delete)
}

type OrderCard @table {
  id: UUID! @default(expr: "uuidV4()")
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # UNIQUE CONSTRAINT - Prevents duplicate orders
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  requestId: String! @unique                    # Links back to AutoQuoteRequest (1:1)
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SUPPLIER & ITEMS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  supplier: Supplier! @relation
  items: String!                                # JSON: [{productId, name, quantity, unitPrice}]
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # QUOTE DATA (Extracted by AI)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  totalValue: Float!
  deliveryDate: Date
  deliveryDays: Int
  availability: String
  paymentTerms: String
  supplierNotes: String
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STATUS & WORKFLOW
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  status: OrderCardStatus! @default(value: PENDING)
  confirmedAt: Timestamp
  confirmedBy: String
  confirmedByName: String
  shippedAt: Timestamp
  receivedAt: Timestamp
  receivedBy: String
  receivedByName: String
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SOFT DELETE FOR AUDIT TRAIL
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  softDeleted: Boolean! @default(value: false)
  deletedAt: Timestamp
  deletedBy: String
  deletedReason: String
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # METADATA
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  createdAt: Timestamp! @default(expr: "request.time")
  updatedAt: Timestamp! @default(expr: "request.time")
}

# ===========================================================
# NOTIFICATION HISTORY
# ===========================================================

enum NotificationType {
  LOW_STOCK
  OUT_OF_STOCK
  PRICE_SPIKE
  PRICE_DROP
  RESTOCK_NEEDED
  ANOMALY_DETECTED
  REPORT_READY
  QUOTATION_RECEIVED
}

type Notification @table {
  id: UUID! @default(expr: "uuidV4()")
  type: NotificationType!
  title: String!
  body: String!
  productId: String
  data: String
  isRead: Boolean! @default(value: false)
  isDismissed: Boolean! @default(value: false)
  createdAt: Timestamp! @default(expr: "request.time")
  readAt: Timestamp
}

# ===========================================================
# APP SETTINGS
# ===========================================================

type AppSettings @table(singular: "appSettings", plural: "appSettingsList") {
  id: UUID! @default(expr: "uuidV4()")
  key: String! @unique
  value: String!
  updatedAt: Timestamp! @default(expr: "request.time")
}

# ===========================================================
# AUDIT LOG (Time Travel)
# ===========================================================

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  MOVEMENT
  ADJUSTMENT
  APPROVAL
}

type AuditLog @table {
  id: UUID! @default(expr: "uuidV4()")
  entityType: String!
  entityId: String!
  action: AuditAction!
  previousState: String
  newState: String
  diff: String
  userId: String
  userName: String
  ipAddress: String
  userAgent: String
  createdAt: Timestamp! @default(expr: "request.time")
}

# ===========================================================
# PURCHASE ORDERS (Smart Sourcing)
# ===========================================================

enum PurchaseOrderStatus {
  DRAFT
  PENDING
  SENT
  CONFIRMED
  RECEIVED
  CANCELLED
}

type PurchaseOrder @table {
  id: UUID! @default(expr: "uuidV4()")
  orderNumber: String!
  supplier: Supplier! @relation
  status: PurchaseOrderStatus! @default(value: DRAFT)
  totalValue: Float! @default(value: 0)
  notes: String
  expectedDelivery: Date
  sentAt: Timestamp
  confirmedAt: Timestamp
  receivedAt: Timestamp
  createdBy: String
  createdAt: Timestamp! @default(expr: "request.time")
  updatedAt: Timestamp! @default(expr: "request.time")
}

type PurchaseOrderItem @table {
  id: UUID! @default(expr: "uuidV4()")
  purchaseOrder: PurchaseOrder! @relation
  product: Product! @relation
  quantity: Float!
  unitPrice: Float!
  totalPrice: Float!
  receivedQuantity: Float @default(value: 0)
  notes: String
}

# ===========================================================
# STOCK SNAPSHOTS (Time Travel States)
# ===========================================================

type StockSnapshot @table {
  id: UUID! @default(expr: "uuidV4()")
  product: Product! @relation
  stock: Float!
  price: Float!
  value: Float!
  triggeredBy: String
  createdAt: Timestamp! @default(expr: "request.time")
}

# ===========================================================
# DEMAND FORECAST (Predictive Order Intelligence)
# ===========================================================
# Stores 90-day demand predictions with seasonal analysis
# Used for automated reorder optimization

type DemandForecast @table {
  id: UUID! @default(expr: "uuidV4()")
  product: Product! @relation
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # FORECAST CONFIGURATION
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  forecastDate: Date!                  # Date of the forecast
  forecastHorizon: Int!                # Days ahead (30, 60, 90)
  method: String! @default(value: "seasonal_decomposition")
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # PREDICTED VALUES
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  predictedDailyDemand: Float!         # Expected daily consumption
  predictedWeeklyDemand: Float!        # Expected weekly consumption
  predictedMonthlyDemand: Float!       # Expected monthly consumption
  lowerBound: Float!                   # 95% CI lower bound
  upperBound: Float!                   # 95% CI upper bound
  confidence: Float!                   # 0-1 confidence score
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # TREND ANALYSIS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  trendDirection: String               # "increasing", "decreasing", "stable"
  trendSlope: Float                    # Rate of change
  trendPercentChange: Float            # % change over period
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # PATTERN DETECTION
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  weeklyPattern: String                # JSON: consumption by day of week
  monthlyPattern: String               # JSON: payday effects
  seasonalFactors: String              # JSON: seasonal adjustments
  detectedAnomalies: String            # JSON: detected anomalies
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ORDER RECOMMENDATIONS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  recommendedOrderDate: Date           # When to place order
  recommendedOrderQuantity: Float      # How much to order
  daysUntilStockout: Int              # Days of stock remaining
  orderUrgency: String                 # "critical", "high", "medium", "low", "none"
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # METADATA
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  inputDataPoints: Int                 # Number of data points used
  computedAt: Timestamp! @default(expr: "request.time")
  expiresAt: Timestamp                 # When forecast should be recalculated
  createdAt: Timestamp! @default(expr: "request.time")
}

# ===========================================================
# CRDT STATE (Conflict-free Multi-Device Sync)
# ===========================================================
# Stores CRDT state for eventual consistency across devices
# Supports: G-Counter, PN-Counter, LWW-Register, LWW-Map

type CRDTState @table {
  id: UUID! @default(expr: "uuidV4()")
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ENTITY REFERENCE
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  entityType: String!                  # "quotation", "order", "product"
  entityId: String!                    # ID of the entity
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # DEVICE TRACKING
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deviceId: String!                    # Unique device identifier
  deviceName: String                   # Human-readable device name
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # VERSION VECTOR (Logical Clock)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  vectorClock: String!                 # JSON: {"device1": 5, "device2": 3}
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # CRDT STATE STORAGE
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  gCounters: String                    # JSON: G-Counter states
  pnCounters: String                   # JSON: PN-Counter states
  lwwRegisters: String                 # JSON: LWW-Register states
  lwwMaps: String                      # JSON: LWW-Map states
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SYNC STATUS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  lastLocalUpdate: Timestamp           # Last local change
  lastSyncAt: Timestamp                # Last sync with server
  syncStatus: String                   # "synced", "pending", "conflict"
  pendingOperations: String            # JSON: unsynced operations
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # METADATA
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  createdAt: Timestamp! @default(expr: "request.time")
  updatedAt: Timestamp! @default(expr: "request.time")
}

# ===========================================================
# EVENT PROJECTION (Time-Travel State Optimization)
# ===========================================================
# Materialized views for fast state lookup without full replay
# Used for time-travel debugging and state reconstruction

type EventProjection @table {
  id: UUID! @default(expr: "uuidV4()")
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # PROJECTION IDENTITY
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  projectionName: String!              # "quotation_state", "order_timeline"
  aggregateType: String!               # "AutoQuoteRequest", "OrderCard"
  aggregateId: String!                 # Entity ID
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # CURRENT STATE
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  projectedState: String!              # JSON: current materialized state
  stateChecksum: String                # Hash for integrity verification
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # EVENT TRACKING
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  lastEventVersion: Int!               # Version of last applied event
  lastEventId: String!                 # ID of last applied event
  lastEventType: String                # Type of last event
  lastEventAt: Timestamp               # When last event occurred
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # TIME-TRAVEL SUPPORT
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  snapshotAt: Timestamp                # When this snapshot was taken
  eventsApplied: Int                   # Total events applied
  rebuildRequired: Boolean! @default(value: false)  # Needs full rebuild
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # METADATA
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  createdAt: Timestamp! @default(expr: "request.time")
  updatedAt: Timestamp! @default(expr: "request.time")
}

# ===========================================================
# INDEXES for Performance
# ===========================================================

extend type Product {
  # Query products by category
  productsByCategory: [Product!]! @index(fields: ["category"])
  # Query products by supplier
  productsBySupplier: [Product!]! @index(fields: ["supplier"])
}

extend type ProductMovement {
  # Query movements by product
  movementsByProduct: [ProductMovement!]! @index(fields: ["product"])
  # Query movements by date range
  movementsByDate: [ProductMovement!]! @index(fields: ["createdAt"])
  # Query movements by type
  movementsByType: [ProductMovement!]! @index(fields: ["type"])
}

extend type Cost {
  # Query costs by date
  costsByDate: [Cost!]! @index(fields: ["date"])
  # Query costs by category
  costsByCategory: [Cost!]! @index(fields: ["category"])
}

extend type Recipe {
  # Query recipes by category
  recipesByCategory: [Recipe!]! @index(fields: ["category"])
}

extend type Quotation {
  # Query quotations by status
  quotationsByStatus: [Quotation!]! @index(fields: ["status"])
  # Query quotations by supplier
  quotationsBySupplier: [Quotation!]! @index(fields: ["supplier"])
}

extend type Notification {
  # Query notifications by read status
  notificationsByRead: [Notification!]! @index(fields: ["isRead"])
}

# ===========================================================
# INDEXES for Auto-Quote System (Duplicate Prevention)
# ===========================================================

extend type AutoQuoteRequest {
  # Query by deduplication key - prevents duplicate pending cards for same product+supplier
  requestsByDedup: [AutoQuoteRequest!]! @index(fields: ["deduplicationKey"])
  # Query by requestId - for email matching
  requestsByRequestId: [AutoQuoteRequest!]! @index(fields: ["requestId"])
  # Query by status - for state-based filtering
  requestsByStatus: [AutoQuoteRequest!]! @index(fields: ["status"])
  # Query by supplier - for supplier dashboard
  requestsBySupplier: [AutoQuoteRequest!]! @index(fields: ["supplier"])
  # Query active (non-soft-deleted) requests
  activeRequests: [AutoQuoteRequest!]! @index(fields: ["softDeleted"])
}

extend type OrderCard {
  # Query by requestId - prevents duplicate orders for same request
  ordersByRequestId: [OrderCard!]! @index(fields: ["requestId"])
  # Query by status - for order dashboard
  ordersByStatus: [OrderCard!]! @index(fields: ["status"])
  # Query by supplier - for supplier analytics
  ordersBySupplier: [OrderCard!]! @index(fields: ["supplier"])
  # Query active (non-soft-deleted) orders
  activeOrders: [OrderCard!]! @index(fields: ["softDeleted"])
}

# ===========================================================
# INDEXES for Advanced Features
# ===========================================================

extend type DemandForecast {
  # Query forecasts by product
  forecastsByProduct: [DemandForecast!]! @index(fields: ["product"])
  # Query forecasts by date for expiration cleanup
  forecastsByDate: [DemandForecast!]! @index(fields: ["forecastDate"])
  # Query forecasts by urgency for alerts
  forecastsByUrgency: [DemandForecast!]! @index(fields: ["orderUrgency"])
}

extend type CRDTState {
  # Query CRDT state by entity
  crdtByEntity: [CRDTState!]! @index(fields: ["entityType", "entityId"])
  # Query CRDT state by device
  crdtByDevice: [CRDTState!]! @index(fields: ["deviceId"])
  # Query pending syncs
  crdtPendingSync: [CRDTState!]! @index(fields: ["syncStatus"])
}

extend type EventProjection {
  # Query projections by aggregate
  projectionsByAggregate: [EventProjection!]! @index(fields: ["aggregateType", "aggregateId"])
  # Query projections by name
  projectionsByName: [EventProjection!]! @index(fields: ["projectionName"])
  # Query projections needing rebuild
  projectionsNeedingRebuild: [EventProjection!]! @index(fields: ["rebuildRequired"])
}
